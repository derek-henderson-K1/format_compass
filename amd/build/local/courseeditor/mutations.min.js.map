{"version":3,"file":"mutations.min.js","sources":["../../../src/local/courseeditor/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport ajax from 'core/ajax';\nimport {get_string as getString} from \"core/str\";\nimport SRLogger from \"core/local/reactive/srlogger\";\n\n/**\n * Flag to determine whether the screen reader-only logger has already been set, so we only need to set it once.\n *\n * @type {boolean}\n */\nlet isLoggerSet = false;\n\n/**\n * Default mutation manager\n *\n * @module     format_compass/local/courseeditor/mutations\n * @class      format_compass/local/courseeditor/mutations\n * @copyright  2023 Knowledgeone inc. <https://knowledgeone.ca>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nexport default class {\n\n    // All course editor mutations for Moodle 4.0 will be located in this file.\n\n    /**\n     * Private method to call core_courseformat_update_course webservice.\n     *\n     * @method _callEditWebservice\n     * @param {string} action\n     * @param {number} courseId\n     * @param {array} ids\n     * @param {number} targetSectionId optional target section id (for moving actions)\n     * @param {number} targetCmId optional target cm id (for moving actions)\n     * @param {array} cutoffs optional assessments cutoffs\n     */\n    async _callEditWebservice(action, courseId, ids, targetSectionId, targetCmId, cutoffs) {\n        const args = {\n            action,\n            courseid: courseId,\n            ids\n        };\n\n        let ajaxresult;\n\n        if (targetSectionId) {\n            args.targetsectionid = targetSectionId;\n        }\n        if (targetCmId) {\n            args.targetcmid = targetCmId;\n        }\n\n        // Check for cutoffs and call the proper update_course\n        if(cutoffs) {\n            args.section = cutoffs;\n            ajaxresult = await ajax.call([{\n                methodname: 'format_compass_update_course',\n                args,\n            }])[0];\n        } else {\n            ajaxresult = await ajax.call([{\n                methodname: 'core_courseformat_update_course',\n                args,\n            }])[0];\n        }\n\n        return JSON.parse(ajaxresult);\n    }\n\n    /**\n     * Private method to call set_course_options webserv1ice.\n     *\n     * @method _callOptionsWebservice\n     * @param {number} courseId\n     * @param {number} cutoffs assessments cutoffs\n     */\n    async _callOptionsWebservice(courseId, cutoffs) {\n        const args = {\n            courseid: courseId,\n            options: [{\n                name: \"assessmentscutoff\",\n                value : cutoffs\n            }]\n        };\n\n        let ajaxresult = await ajax.call([{\n            methodname: 'format_compass_set_course_options',\n            args,\n        }])[0];\n        return JSON.parse(ajaxresult);\n    }\n\n    /**\n     * Execute a basic section state action.\n     * @param {StateManager} stateManager the current state manager\n     * @param {string} action the action name\n     * @param {array} sectionIds the section ids\n     * @param {number} targetSectionId optional target section id (for moving actions)\n     * @param {number} targetCmId optional target cm id (for moving actions)\n     */\n    async _sectionBasicAction(stateManager, action, sectionIds, targetSectionId, targetCmId) {\n        const logEntry = this._getLoggerEntry(stateManager, action, sectionIds, {\n            targetSectionId,\n            targetCmId,\n            itemType: 'section',\n        });\n        const course = stateManager.get('course');\n        this.sectionLock(stateManager, sectionIds, true);\n        const updates = await this._callEditWebservice(\n            action,\n            course.id,\n            sectionIds,\n            targetSectionId,\n            targetCmId,\n        );\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, sectionIds, false);\n        stateManager.addLoggerEntry(await logEntry);\n    }\n\n    /**\n     * Execute a basic course module state action.\n     * @param {StateManager} stateManager the current state manager\n     * @param {string} action the action name\n     * @param {array} cmIds the cm ids\n     * @param {number} targetSectionId optional target section id (for moving actions)\n     * @param {number} targetCmId optional target cm id (for moving actions)\n     */\n    async _cmBasicAction(stateManager, action, cmIds, targetSectionId, targetCmId) {\n        const logEntry = this._getLoggerEntry(stateManager, action, cmIds, {\n            targetSectionId,\n            targetCmId,\n            itemType: 'cm',\n        });\n        const course = stateManager.get('course');\n        this.cmLock(stateManager, cmIds, true);\n        const updates = await this._callEditWebservice(\n            action,\n            course.id,\n            cmIds,\n            targetSectionId,\n            targetCmId\n        );\n        stateManager.processUpdates(updates);\n        this.cmLock(stateManager, cmIds, false);\n        stateManager.addLoggerEntry(await logEntry);\n    }\n\n    /**\n     * Get log entry for the current action.\n     * @param {StateManager} stateManager the current state manager\n     * @param {string} action the action name\n     * @param {int[]|null} itemIds the element ids\n     * @param {Object|undefined} data extra params for the log entry\n     * @param {string|undefined} data.itemType the element type (will be taken from action if none)\n     * @param {int|null|undefined} data.targetSectionId the target section id\n     * @param {int|null|undefined} data.targetCmId the target cm id\n     * @param {String|null|undefined} data.component optional component (for format plugins)\n     * @return {Object} the log entry\n     */\n    async _getLoggerEntry(stateManager, action, itemIds, data = {}) {\n        if (!isLoggerSet) {\n            // In case the logger has not been set from init(), ensure we set the logger.\n            stateManager.setLogger(new SRLogger());\n            isLoggerSet = true;\n        }\n        const feedbackParams = {\n            action,\n            itemType: data.itemType ?? action.split('_')[0],\n        };\n        let batch = '';\n        if (itemIds.length > 1) {\n            feedbackParams.count = itemIds.length;\n            batch = '_batch';\n        } else if (itemIds.length === 1) {\n            const itemInfo = stateManager.get(feedbackParams.itemType, itemIds[0]);\n            feedbackParams.name = itemInfo.title ?? itemInfo.name;\n            // Apply shortener for modules like label.\n        }\n        if (data.targetSectionId) {\n            feedbackParams.targetSectionName = stateManager.get('section', data.targetSectionId).title;\n        }\n        if (data.targetCmId) {\n            feedbackParams.targetCmName = stateManager.get('cm', data.targetCmId).name;\n        }\n\n        const message = await getString(\n            `${action.toLowerCase()}_feedback${batch}`,\n            data.component ?? 'core_courseformat',\n            feedbackParams\n        );\n\n        return {\n            feedbackMessage: message,\n        };\n    }\n\n    /**\n     * Mutation module initialize.\n     *\n     * The reactive instance will execute this method when addMutations or setMutation is invoked.\n     *\n     * @param {StateManager} stateManager the state manager\n     */\n    init(stateManager) {\n        // Add a method to prepare the fields when some update is coming from the server.\n        stateManager.addUpdateTypes({\n            prepareFields: this._prepareFields,\n        });\n        // Use the screen reader-only logger (SRLogger) to handle the feedback messages from the mutations.\n        stateManager.setLogger(new SRLogger());\n        isLoggerSet = true;\n    }\n\n    /**\n     * Add default values to state elements.\n     *\n     * This method is called every time a webservice returns a update state message.\n     *\n     * @param {Object} stateManager the state manager\n     * @param {String} updateName the state element to update\n     * @param {Object} fields the new data\n     * @returns {Object} final fields data\n     */\n    _prepareFields(stateManager, updateName, fields) {\n        // Any update should unlock the element.\n        fields.locked = false;\n        return fields;\n    }\n\n    /**\n     * Hides sections.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     */\n    async sectionHide(stateManager, sectionIds) {\n        await this._sectionBasicAction(stateManager, 'section_hide', sectionIds);\n    }\n\n    /**\n     * Show sections.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     */\n    async sectionShow(stateManager, sectionIds) {\n        await this._sectionBasicAction(stateManager, 'section_show', sectionIds);\n    }\n\n    /**\n     * Show cms.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmShow(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_show', cmIds);\n    }\n\n    /**\n     * Hide cms.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmHide(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_hide', cmIds);\n    }\n\n    /**\n     * Stealth cms.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmStealth(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_stealth', cmIds);\n    }\n\n    /**\n     * Move course modules to specific course location.\n     *\n     * Note that one of targetSectionId or targetCmId should be provided in order to identify the\n     * new location:\n     *  - targetCmId: the activities will be located avobe the target cm. The targetSectionId\n     *                value will be ignored in this case.\n     *  - targetSectionId: the activities will be appended to the section. In this case\n     *                     targetSectionId should not be present.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmids the list of cm ids to move\n     * @param {number} targetSectionId the target section id\n     * @param {number} targetCmId the target course module id\n     */\n    async cmMove(stateManager, cmids, targetSectionId, targetCmId) {\n        if (!targetSectionId && !targetCmId) {\n            throw new Error(`Mutation cmMove requires targetSectionId or targetCmId`);\n        }\n        const course = stateManager.get('course');\n        this.cmLock(stateManager, cmids, true);\n        const updates = await this._callEditWebservice('cm_move', course.id, cmids, targetSectionId, targetCmId);\n        stateManager.processUpdates(updates);\n        this.cmLock(stateManager, cmids, false);\n    }\n\n    /**\n     * Move course modules to specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids to move\n     * @param {number} targetSectionId the target section id\n     * @param {array} cutoffs Assessments cutoffs\n     */\n    async sectionMove(stateManager, sectionIds, targetSectionId, cutoffs) {\n        if (!targetSectionId) {\n            throw new Error(`Mutation sectionMove requires targetSectionId`);\n        }\n        const course = stateManager.get('course');\n        this.sectionLock(stateManager, sectionIds, true);\n        const updates = await this._callEditWebservice('section_move', course.id, sectionIds, targetSectionId, null, cutoffs);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, sectionIds, false);\n    }\n\n    /**\n     * Move course modules to specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cutoffs Assessments cutoffs\n     */\n    async saveCutoffs(stateManager, cutoffs) {\n        const course = stateManager.get('course');\n        const updates = await this._callOptionsWebservice(course.id, cutoffs);\n        stateManager.processUpdates(updates);\n    }\n\n    /**\n     * Add a new section to a specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {number} targetSectionId optional the target section id\n     * @param {number} cutoffs optional the cutoff value\n     */\n    async addSection(stateManager, targetSectionId, cutoffs) {\n        if (!targetSectionId) {\n            targetSectionId = 0;\n        }\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('section_add', course.id, [], targetSectionId, null, cutoffs);\n        stateManager.processUpdates(updates);\n    }\n\n    /**\n     * Delete sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of course modules ids\n     * @param {array} cutoffs assessments cutoffs\n     */\n    async sectionDelete(stateManager, sectionIds, cutoffs) {\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('section_delete', course.id, sectionIds, null, null, cutoffs);\n        stateManager.processUpdates(updates);\n\n    }\n\n    /**\n     * Mark or unmark course modules as dragging.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {bool} dragValue the new dragging value\n     */\n    cmDrag(stateManager, cmIds, dragValue) {\n        this.setPageItem(stateManager);\n        this._setElementsValue(stateManager, 'cm', cmIds, 'dragging', dragValue);\n    }\n\n    /**\n     * Mark or unmark course sections as dragging.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     * @param {bool} dragValue the new dragging value\n     */\n    sectionDrag(stateManager, sectionIds, dragValue) {\n        this.setPageItem(stateManager);\n        this._setElementsValue(stateManager, 'section', sectionIds, 'dragging', dragValue);\n    }\n\n    /**\n     * Mark or unmark course modules as complete.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {bool} complete the new completion value\n     */\n    cmCompletion(stateManager, cmIds, complete) {\n        const newValue = (complete) ? 1 : 0;\n        this._setElementsValue(stateManager, 'cm', cmIds, 'completionstate', newValue);\n    }\n\n    /**\n     * Move cms to the right: indent = 1.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmMoveRight(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_moveright', cmIds);\n    }\n\n    /**\n     * Move cms to the left: indent = 0.\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of cm ids\n     */\n    async cmMoveLeft(stateManager, cmIds) {\n        await this._cmBasicAction(stateManager, 'cm_moveleft', cmIds);\n    }\n\n    /**\n     * Lock or unlock course modules.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {bool} lockValue the new locked value\n     */\n    cmLock(stateManager, cmIds, lockValue) {\n        this._setElementsValue(stateManager, 'cm', cmIds, 'locked', lockValue);\n    }\n\n    /**\n     * Lock or unlock course sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     * @param {bool} lockValue the new locked value\n     */\n    sectionLock(stateManager, sectionIds, lockValue) {\n        this._setElementsValue(stateManager, 'section', sectionIds, 'locked', lockValue);\n    }\n\n    _setElementsValue(stateManager, name, ids, fieldName, newValue) {\n        stateManager.setReadOnly(false);\n        ids.forEach((id) => {\n            const element = stateManager.get(name, id);\n            if (element) {\n                element[fieldName] = newValue;\n            }\n        });\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Set the page current item.\n     *\n     * Only one element of the course state can be the page item at a time.\n     *\n     * There are several actions that can alter the page current item. For example, when the user is in an activity\n     * page, the page item is always the activity one. However, in a course page, when the user scrolls to an element,\n     * this element get the page item.\n     *\n     * If the page item is static means that it is not meant to change. This is important because\n     * static page items has some special logic. For example, if a cm is the static page item\n     * and it is inside a collapsed section, the course index will expand the section to make it visible.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {String|undefined} type the element type (section or cm). Undefined will remove the current page item.\n     * @param {Number|undefined} id the element id\n     * @param {boolean|undefined} isStatic if the page item is static\n     */\n    setPageItem(stateManager, type, id, isStatic) {\n        let newPageItem;\n        if (type !== undefined) {\n            newPageItem = stateManager.get(type, id);\n            if (!newPageItem) {\n                return;\n            }\n        }\n        stateManager.setReadOnly(false);\n        // Remove the current page item.\n        const course = stateManager.get('course');\n        course.pageItem = null;\n        // Save the new page item.\n        if (newPageItem) {\n            course.pageItem = {\n                id,\n                type,\n                sectionId: (type == 'section') ? newPageItem.id : newPageItem.sectionid,\n                isStatic,\n            };\n        }\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Unlock all course elements.\n     *\n     * @param {StateManager} stateManager the current state manager\n     */\n    unlockAll(stateManager) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        state.section.forEach((section) => {\n            section.locked = false;\n        });\n        state.cm.forEach((cm) => {\n            cm.locked = false;\n        });\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Update the course index collapsed attribute of some sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the affected section ids\n     * @param {boolean} collapsed the new collapsed value\n     */\n    async sectionIndexCollapsed(stateManager, sectionIds, collapsed) {\n        const affectedSections = this._updateStateSectionPreference(stateManager, 'indexcollapsed', sectionIds, collapsed);\n        if (!affectedSections) {\n            return;\n        }\n        const course = stateManager.get('course');\n        let actionName = 'section_index_collapsed';\n        if (!collapsed) {\n            actionName = 'section_index_expanded';\n        }\n        await this._callEditWebservice(actionName, course.id, affectedSections);\n    }\n\n    /**\n     * Update the course content collapsed attribute of some sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the affected section ids\n     * @param {boolean} collapsed the new collapsed value\n     */\n    async sectionContentCollapsed(stateManager, sectionIds, collapsed) {\n        const affectedSections = this._updateStateSectionPreference(stateManager, 'contentcollapsed', sectionIds, collapsed);\n        if (!affectedSections) {\n            return;\n        }\n        const course = stateManager.get('course');\n        let actionName = 'section_content_collapsed';\n        if (!collapsed) {\n            actionName = 'section_content_expanded';\n        }\n        await this._callEditWebservice(actionName, course.id, affectedSections);\n    }\n\n    /**\n     * Private batch update for a section preference attribute.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {string} preferenceName the preference name\n     * @param {array} sectionIds the affected section ids\n     * @param {boolean} preferenceValue the new preferenceValue value\n     * @return {Number[]|null} sections ids with the preference value true or null if no update is required\n     */\n    _updateStateSectionPreference(stateManager, preferenceName, sectionIds, preferenceValue) {\n        stateManager.setReadOnly(false);\n        const affectedSections = [];\n        // Check if we need to update preferences.\n        sectionIds.forEach(sectionId => {\n            const section = stateManager.get('section', sectionId);\n            if (section === undefined) {\n                stateManager.setReadOnly(true);\n                return null;\n            }\n            const newValue = preferenceValue ?? section[preferenceName];\n            if (section[preferenceName] != newValue) {\n                section[preferenceName] = newValue;\n                affectedSections.push(section.id);\n            }\n        });\n        stateManager.setReadOnly(true);\n        return affectedSections;\n    }\n\n    /**\n     * Get updated state data related to some cm ids.\n     *\n     * @method cmState\n     * @param {StateManager} stateManager the current state\n     * @param {array} cmids the list of cm ids to update\n     */\n    async cmState(stateManager, cmids) {\n        this.cmLock(stateManager, cmids, true);\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('cm_state', course.id, cmids);\n        stateManager.processUpdates(updates);\n        this.cmLock(stateManager, cmids, false);\n    }\n\n    /**\n     * Get updated state data related to some section ids.\n     *\n     * @method sectionState\n     * @param {StateManager} stateManager the current state\n     * @param {array} sectionIds the list of section ids to update\n     */\n    async sectionState(stateManager, sectionIds) {\n        this.sectionLock(stateManager, sectionIds, true);\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('section_state', course.id, sectionIds);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, sectionIds, false);\n    }\n\n    /**\n     * Get the full updated state data of the course.\n     *\n     * @param {StateManager} stateManager the current state\n     */\n    async courseState(stateManager) {\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('course_state', course.id);\n        stateManager.processUpdates(updates);\n    }\n\n     /**\n     * Update state on section rename\n     *\n     * @param {StateManager} stateManager the current state\n     * @param {array} data\n     */\n     async sectionRenameState(stateManager, data) {\n        const updates = [{\n            action : \"put\",\n            name: \"section\",\n            \"fields\" : {\n                id : data.id,\n                title : data.name,\n                subname : data.subname\n            }\n        }];\n        stateManager.processUpdates(updates);\n    }\n\n    /**\n     * Update state on section gradeweight\n     *\n     * @param {StateManager} stateManager the current state\n     * @param {array} data\n     */\n    async sectionEditGradeWeight(stateManager, data) {\n        const updates = [{\n            action : \"put\",\n            name: \"section\",\n            \"fields\" : {\n                id : data.id,\n                title : data.name,\n                sectionweight : {\n                    type_of_grade_weighting : data.type_of_grade_weighting,\n                    weighttype_bonus_value : data.weighttype_bonus_value,\n                    weighttype_singlemultiple : data.weighttype_singlemultiple,\n                    weighttype_singlevalue_weightvalue : data.weighttype_singlevalue_weightvalue,\n                    weighttype_multiplier_weightvalue : data.weighttype_multiplier_weightvalue,\n                    weighttype_multiplier_multipliervalue : data.weighttype_multiplier_multipliervalue,\n                    weighttype_multiplier_csvvalue : data.weighttype_multiplier_csvvalue,\n                }\n            }\n        }];\n        stateManager.processUpdates(updates);\n    }\n\n}"],"names":["isLoggerSet","action","courseId","ids","targetSectionId","targetCmId","cutoffs","args","courseid","ajaxresult","targetsectionid","targetcmid","section","ajax","call","methodname","JSON","parse","options","name","value","stateManager","sectionIds","logEntry","this","_getLoggerEntry","itemType","course","get","sectionLock","updates","_callEditWebservice","id","processUpdates","addLoggerEntry","cmIds","cmLock","itemIds","data","setLogger","SRLogger","feedbackParams","split","batch","length","count","itemInfo","title","targetSectionName","targetCmName","feedbackMessage","toLowerCase","component","init","addUpdateTypes","prepareFields","_prepareFields","updateName","fields","locked","_sectionBasicAction","_cmBasicAction","cmids","Error","_callOptionsWebservice","cmDrag","dragValue","setPageItem","_setElementsValue","sectionDrag","cmCompletion","complete","newValue","lockValue","fieldName","setReadOnly","forEach","element","type","isStatic","newPageItem","undefined","pageItem","sectionId","sectionid","unlockAll","state","cm","collapsed","affectedSections","_updateStateSectionPreference","actionName","preferenceName","preferenceValue","push","subname","sectionweight","type_of_grade_weighting","weighttype_bonus_value","weighttype_singlemultiple","weighttype_singlevalue_weightvalue","weighttype_multiplier_weightvalue","weighttype_multiplier_multipliervalue","weighttype_multiplier_csvvalue"],"mappings":"sZAwBIA,aAAc;;;;;;;;6DAyBYC,OAAQC,SAAUC,IAAKC,gBAAiBC,WAAYC,eACpEC,KAAO,CACTN,OAAAA,OACAO,SAAUN,SACVC,IAAAA,SAGAM,kBAEAL,kBACAG,KAAKG,gBAAkBN,iBAEvBC,aACAE,KAAKI,WAAaN,YAInBC,SACCC,KAAKK,QAAUN,QACfG,iBAAmBI,cAAKC,KAAK,CAAC,CAC1BC,WAAY,+BACZR,KAAAA,QACA,IAEJE,iBAAmBI,cAAKC,KAAK,CAAC,CAC1BC,WAAY,kCACZR,KAAAA,QACA,GAGDS,KAAKC,MAAMR,yCAUOP,SAAUI,eAC7BC,KAAO,CACTC,SAAUN,SACVgB,QAAS,CAAC,CACNC,KAAM,oBACNC,MAAQd,eAIZG,iBAAmBI,cAAKC,KAAK,CAAC,CAC9BC,WAAY,oCACZR,KAAAA,QACA,UACGS,KAAKC,MAAMR,sCAWIY,aAAcpB,OAAQqB,WAAYlB,gBAAiBC,kBACnEkB,SAAWC,KAAKC,gBAAgBJ,aAAcpB,OAAQqB,WAAY,CACpElB,gBAAAA,gBACAC,WAAAA,WACAqB,SAAU,YAERC,OAASN,aAAaO,IAAI,eAC3BC,YAAYR,aAAcC,YAAY,SACrCQ,cAAgBN,KAAKO,oBACvB9B,OACA0B,OAAOK,GACPV,WACAlB,gBACAC,YAEJgB,aAAaY,eAAeH,cACvBD,YAAYR,aAAcC,YAAY,GAC3CD,aAAaa,qBAAqBX,+BAWjBF,aAAcpB,OAAQkC,MAAO/B,gBAAiBC,kBACzDkB,SAAWC,KAAKC,gBAAgBJ,aAAcpB,OAAQkC,MAAO,CAC/D/B,gBAAAA,gBACAC,WAAAA,WACAqB,SAAU,OAERC,OAASN,aAAaO,IAAI,eAC3BQ,OAAOf,aAAcc,OAAO,SAC3BL,cAAgBN,KAAKO,oBACvB9B,OACA0B,OAAOK,GACPG,MACA/B,gBACAC,YAEJgB,aAAaY,eAAeH,cACvBM,OAAOf,aAAcc,OAAO,GACjCd,aAAaa,qBAAqBX,gCAehBF,aAAcpB,OAAQoC,gDAASC,4DAAO,GACnDtC,cAEDqB,aAAakB,UAAU,IAAIC,mBAC3BxC,aAAc,SAEZyC,eAAiB,CACnBxC,OAAAA,OACAyB,gCAAUY,KAAKZ,kDAAYzB,OAAOyC,MAAM,KAAK,QAE7CC,MAAQ,MACRN,QAAQO,OAAS,EACjBH,eAAeI,MAAQR,QAAQO,OAC/BD,MAAQ,cACL,GAAuB,IAAnBN,QAAQO,OAAc,2BACvBE,SAAWzB,aAAaO,IAAIa,eAAef,SAAUW,QAAQ,IACnEI,eAAetB,6BAAO2B,SAASC,iDAASD,SAAS3B,KAGjDmB,KAAKlC,kBACLqC,eAAeO,kBAAoB3B,aAAaO,IAAI,UAAWU,KAAKlC,iBAAiB2C,OAErFT,KAAKjC,aACLoC,eAAeQ,aAAe5B,aAAaO,IAAI,KAAMU,KAAKjC,YAAYc,YASnE,CACH+B,sBAPkB,6BACfjD,OAAOkD,kCAAyBR,+BACnCL,KAAKc,qDAAa,oBAClBX,iBAeRY,KAAKhC,cAEDA,aAAaiC,eAAe,CACxBC,cAAe/B,KAAKgC,iBAGxBnC,aAAakB,UAAU,IAAIC,mBAC3BxC,aAAc,EAalBwD,eAAenC,aAAcoC,WAAYC,eAErCA,OAAOC,QAAS,EACTD,yBAQOrC,aAAcC,kBACtBE,KAAKoC,oBAAoBvC,aAAc,eAAgBC,8BAQ/CD,aAAcC,kBACtBE,KAAKoC,oBAAoBvC,aAAc,eAAgBC,yBAQpDD,aAAcc,aACjBX,KAAKqC,eAAexC,aAAc,UAAWc,oBAQ1Cd,aAAcc,aACjBX,KAAKqC,eAAexC,aAAc,UAAWc,uBAQvCd,aAAcc,aACpBX,KAAKqC,eAAexC,aAAc,aAAcc,oBAkB7Cd,aAAcyC,MAAO1D,gBAAiBC,gBAC1CD,kBAAoBC,iBACf,IAAI0D,sEAERpC,OAASN,aAAaO,IAAI,eAC3BQ,OAAOf,aAAcyC,OAAO,SAC3BhC,cAAgBN,KAAKO,oBAAoB,UAAWJ,OAAOK,GAAI8B,MAAO1D,gBAAiBC,YAC7FgB,aAAaY,eAAeH,cACvBM,OAAOf,aAAcyC,OAAO,qBAWnBzC,aAAcC,WAAYlB,gBAAiBE,aACpDF,sBACK,IAAI2D,6DAERpC,OAASN,aAAaO,IAAI,eAC3BC,YAAYR,aAAcC,YAAY,SACrCQ,cAAgBN,KAAKO,oBAAoB,eAAgBJ,OAAOK,GAAIV,WAAYlB,gBAAiB,KAAME,SAC7Ge,aAAaY,eAAeH,cACvBD,YAAYR,aAAcC,YAAY,qBAS7BD,aAAcf,eACtBqB,OAASN,aAAaO,IAAI,UAC1BE,cAAgBN,KAAKwC,uBAAuBrC,OAAOK,GAAI1B,SAC7De,aAAaY,eAAeH,0BAUfT,aAAcjB,gBAAiBE,SACvCF,kBACDA,gBAAkB,SAEhBuB,OAASN,aAAaO,IAAI,UAC1BE,cAAgBN,KAAKO,oBAAoB,cAAeJ,OAAOK,GAAI,GAAI5B,gBAAiB,KAAME,SACpGe,aAAaY,eAAeH,6BAUZT,aAAcC,WAAYhB,eACpCqB,OAASN,aAAaO,IAAI,UAC1BE,cAAgBN,KAAKO,oBAAoB,iBAAkBJ,OAAOK,GAAIV,WAAY,KAAM,KAAMhB,SACpGe,aAAaY,eAAeH,SAWhCmC,OAAO5C,aAAcc,MAAO+B,gBACnBC,YAAY9C,mBACZ+C,kBAAkB/C,aAAc,KAAMc,MAAO,WAAY+B,WAUlEG,YAAYhD,aAAcC,WAAY4C,gBAC7BC,YAAY9C,mBACZ+C,kBAAkB/C,aAAc,UAAWC,WAAY,WAAY4C,WAU5EI,aAAajD,aAAcc,MAAOoC,gBACxBC,SAAYD,SAAY,EAAI,OAC7BH,kBAAkB/C,aAAc,KAAMc,MAAO,kBAAmBqC,4BAQvDnD,aAAcc,aACtBX,KAAKqC,eAAexC,aAAc,eAAgBc,wBAQ3Cd,aAAcc,aACrBX,KAAKqC,eAAexC,aAAc,cAAec,OAU3DC,OAAOf,aAAcc,MAAOsC,gBACnBL,kBAAkB/C,aAAc,KAAMc,MAAO,SAAUsC,WAUhE5C,YAAYR,aAAcC,WAAYmD,gBAC7BL,kBAAkB/C,aAAc,UAAWC,WAAY,SAAUmD,WAG1EL,kBAAkB/C,aAAcF,KAAMhB,IAAKuE,UAAWF,UAClDnD,aAAasD,aAAY,GACzBxE,IAAIyE,SAAS5C,WACH6C,QAAUxD,aAAaO,IAAIT,KAAMa,IACnC6C,UACAA,QAAQH,WAAaF,aAG7BnD,aAAasD,aAAY,GAqB7BR,YAAY9C,aAAcyD,KAAM9C,GAAI+C,cAC5BC,oBACSC,IAATH,OACAE,YAAc3D,aAAaO,IAAIkD,KAAM9C,KAChCgD,oBAIT3D,aAAasD,aAAY,SAEnBhD,OAASN,aAAaO,IAAI,UAChCD,OAAOuD,SAAW,KAEdF,cACArD,OAAOuD,SAAW,CACdlD,GAAAA,GACA8C,KAAAA,KACAK,UAAoB,WAARL,KAAqBE,YAAYhD,GAAKgD,YAAYI,UAC9DL,SAAAA,WAGR1D,aAAasD,aAAY,GAQ7BU,UAAUhE,oBACAiE,MAAQjE,aAAaiE,MAC3BjE,aAAasD,aAAY,GACzBW,MAAM1E,QAAQgE,SAAShE,UACnBA,QAAQ+C,QAAS,KAErB2B,MAAMC,GAAGX,SAASW,KACdA,GAAG5B,QAAS,KAEhBtC,aAAasD,aAAY,+BAUDtD,aAAcC,WAAYkE,iBAC5CC,iBAAmBjE,KAAKkE,8BAA8BrE,aAAc,iBAAkBC,WAAYkE,eACnGC,8BAGC9D,OAASN,aAAaO,IAAI,cAC5B+D,WAAa,0BACZH,YACDG,WAAa,gCAEXnE,KAAKO,oBAAoB4D,WAAYhE,OAAOK,GAAIyD,gDAU5BpE,aAAcC,WAAYkE,iBAC9CC,iBAAmBjE,KAAKkE,8BAA8BrE,aAAc,mBAAoBC,WAAYkE,eACrGC,8BAGC9D,OAASN,aAAaO,IAAI,cAC5B+D,WAAa,4BACZH,YACDG,WAAa,kCAEXnE,KAAKO,oBAAoB4D,WAAYhE,OAAOK,GAAIyD,kBAY1DC,8BAA8BrE,aAAcuE,eAAgBtE,WAAYuE,iBACpExE,aAAasD,aAAY,SACnBc,iBAAmB,UAEzBnE,WAAWsD,SAAQO,kBACTvE,QAAUS,aAAaO,IAAI,UAAWuD,mBAC5BF,IAAZrE,eACAS,aAAasD,aAAY,GAClB,WAELH,SAAWqB,MAAAA,gBAAAA,gBAAmBjF,QAAQgF,gBACxChF,QAAQgF,iBAAmBpB,WAC3B5D,QAAQgF,gBAAkBpB,SAC1BiB,iBAAiBK,KAAKlF,QAAQoB,QAGtCX,aAAasD,aAAY,GAClBc,+BAUGpE,aAAcyC,YACnB1B,OAAOf,aAAcyC,OAAO,SAC3BnC,OAASN,aAAaO,IAAI,UAC1BE,cAAgBN,KAAKO,oBAAoB,WAAYJ,OAAOK,GAAI8B,OACtEzC,aAAaY,eAAeH,cACvBM,OAAOf,aAAcyC,OAAO,sBAUlBzC,aAAcC,iBACxBO,YAAYR,aAAcC,YAAY,SACrCK,OAASN,aAAaO,IAAI,UAC1BE,cAAgBN,KAAKO,oBAAoB,gBAAiBJ,OAAOK,GAAIV,YAC3ED,aAAaY,eAAeH,cACvBD,YAAYR,aAAcC,YAAY,qBAQ7BD,oBACRM,OAASN,aAAaO,IAAI,UAC1BE,cAAgBN,KAAKO,oBAAoB,eAAgBJ,OAAOK,IACtEX,aAAaY,eAAeH,kCASNT,aAAciB,YAC9BR,QAAU,CAAC,CACb7B,OAAS,MACTkB,KAAM,iBACK,CACPa,GAAKM,KAAKN,GACVe,MAAQT,KAAKnB,KACb4E,QAAUzD,KAAKyD,WAGvB1E,aAAaY,eAAeH,sCASHT,aAAciB,YACjCR,QAAU,CAAC,CACb7B,OAAS,MACTkB,KAAM,iBACK,CACPa,GAAKM,KAAKN,GACVe,MAAQT,KAAKnB,KACb6E,cAAgB,CACZC,wBAA0B3D,KAAK2D,wBAC/BC,uBAAyB5D,KAAK4D,uBAC9BC,0BAA4B7D,KAAK6D,0BACjCC,mCAAqC9D,KAAK8D,mCAC1CC,kCAAoC/D,KAAK+D,kCACzCC,sCAAwChE,KAAKgE,sCAC7CC,+BAAiCjE,KAAKiE,mCAIlDlF,aAAaY,eAAeH"}